--[[
    Trader Exploit Scanner & Exploit Tool
    Foco: Sistemas de Trading e Economia
    Autor: AI Assistant
    Versão: 1.0
]]

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- Configurações
local CONFIG = {
    DEBUG = true,
    AUTO_EXPLOIT = true,
    REPORT_DETAILED = true,
    SCAN_DEEP = true,
    TARGET_TRADING_SYSTEMS = {"Trade", "Trading", "Market", "Shop", "Store", "Sell", "Buy", "Exchange"}
}

-- Utilitários
local Utils = {}

function Utils:Log(message, level)
    level = level or "INFO"
    local timestamp = os.date("%H:%M:%S")
    print(string.format("[%s] [%s] %s", timestamp, level, message))
end

-- Scanner de Vulnerabilidades de Trading
local TradingScanner = {}

function TradingScanner:ScanTradingRemotes()
    Utils:Log("Iniciando scan de remotes de trading...", "SCAN")
    
    local vulnerabilities = {}
    
    -- Procurar por remotes relacionados a trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
            local name = string.lower(obj.Name)
            
            -- Verificar se é relacionado a trading
            for _, tradingKeyword in pairs(CONFIG.TARGET_TRADING_SYSTEMS) do
                if string.find(name, string.lower(tradingKeyword)) then
                    local remoteInfo = {
                        name = obj.Name,
                        parent = obj.Parent.Name,
                        type = obj.ClassName,
                        path = obj:GetFullName(),
                        keyword = tradingKeyword
                    }
                    
                    -- Verificar se está exposto
                    if obj.Parent == game or obj.Parent.Parent == game then
                        remoteInfo.exposed = true
                        table.insert(vulnerabilities, {
                            type = "EXPOSED_TRADING_REMOTE",
                            severity = "CRITICAL",
                            info = remoteInfo
                        })
                    else
                        table.insert(vulnerabilities, {
                            type = "TRADING_REMOTE",
                            severity = "HIGH",
                            info = remoteInfo
                        })
                    end
                    
                    Utils:Log("Remote de trading encontrado: " .. obj.Name .. " | Tipo: " .. obj.ClassName, "INFO")
                    break
                end
            end
        end
    end
    
    return vulnerabilities
end

function TradingScanner:ScanTradingScripts()
    Utils:Log("Iniciando scan de scripts de trading...", "SCAN")
    
    local vulnerabilities = {}
    
    -- Procurar por scripts de trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("Script") or obj:IsA("LocalScript") then
            local name = string.lower(obj.Name)
            
            for _, tradingKeyword in pairs(CONFIG.TARGET_TRADING_SYSTEMS) do
                if string.find(name, string.lower(tradingKeyword)) then
                    Utils:Log("Script de trading encontrado: " .. obj.Name, "INFO")
                    
                    -- Tentar acessar o script
                    local success, result = pcall(function()
                        return obj.Source
                    end)
                    
                    if success then
                        table.insert(vulnerabilities, {
                            type = "TRADING_SCRIPT_ACCESS",
                            severity = "HIGH",
                            info = "Script de trading acessível: " .. obj.Name
                        })
                    end
                    break
                end
            end
        end
    end
    
    return vulnerabilities
end

function TradingScanner:ScanTradingValues()
    Utils:Log("Iniciando scan de valores de trading...", "SCAN")
    
    local vulnerabilities = {}
    
    -- Procurar por valores relacionados a trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("IntValue") or obj:IsA("NumberValue") or obj:IsA("StringValue") then
            local name = string.lower(obj.Name)
            
            -- Verificar se é relacionado a trading
            local tradingKeywords = {"price", "cost", "value", "amount", "quantity", "currency", "money", "coins", "cash", "gold", "diamonds", "robux"}
            
            for _, keyword in pairs(tradingKeywords) do
                if string.find(name, keyword) then
                    local valueInfo = {
                        name = obj.Name,
                        parent = obj.Parent.Name,
                        type = obj.ClassName,
                        path = obj:GetFullName(),
                        currentValue = obj.Value,
                        keyword = keyword
                    }
                    
                    -- Verificar se o valor pode ser modificado
                    local originalValue = obj.Value
                    local success = pcall(function()
                        if obj:IsA("IntValue") or obj:IsA("NumberValue") then
                            obj.Value = 999999
                        end
                    end)
                    
                    if success then
                        valueInfo.modifiable = true
                        obj.Value = originalValue -- Restaurar valor original
                        
                        table.insert(vulnerabilities, {
                            type = "MODIFIABLE_TRADING_VALUE",
                            severity = "CRITICAL",
                            info = valueInfo
                        })
                    else
                        valueInfo.modifiable = false
                        table.insert(vulnerabilities, {
                            type = "TRADING_VALUE",
                            severity = "MEDIUM",
                            info = valueInfo
                        })
                    end
                    
                    Utils:Log("Valor de trading encontrado: " .. obj.Name .. " | Valor: " .. tostring(obj.Value), "INFO")
                    break
                end
            end
        end
    end
    
    return vulnerabilities
end

function TradingScanner:ScanTradingUI()
    Utils:Log("Iniciando scan de interface de trading...", "SCAN")
    
    local vulnerabilities = {}
    
    -- Procurar por elementos de UI relacionados a trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("ScreenGui") or obj:IsA("GuiObject") then
            local name = string.lower(obj.Name)
            
            for _, tradingKeyword in pairs(CONFIG.TARGET_TRADING_SYSTEMS) do
                if string.find(name, string.lower(tradingKeyword)) then
                    Utils:Log("UI de trading encontrada: " .. obj.Name, "INFO")
                    
                    -- Verificar se pode ser modificada
                    local success = pcall(function()
                        if obj:IsA("TextLabel") or obj:IsA("TextButton") then
                            local originalText = obj.Text
                            obj.Text = "999999"
                            obj.Text = originalText
                        end
                    end)
                    
                    if success then
                        table.insert(vulnerabilities, {
                            type = "MODIFIABLE_TRADING_UI",
                            severity = "MEDIUM",
                            info = "UI de trading modificável: " .. obj.Name
                        })
                    end
                    break
                end
            end
        end
    end
    
    return vulnerabilities
end

-- Exploit Engine para Trading
local TradingExploit = {}

function TradingExploit:ExecuteTradingRemote(remote, args)
    if not remote then return false end
    
    local success, result = pcall(function()
        if remote:IsA("RemoteEvent") then
            remote:FireServer(unpack(args or {}))
        elseif remote:IsA("RemoteFunction") then
            return remote:InvokeServer(unpack(args or {}))
        end
    end)
    
    return success, result
end

function TradingExploit:DuplicateItems()
    Utils:Log("Tentando duplicar itens...", "EXPLOIT")
    
    -- Procurar por remotes de trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
            local name = string.lower(obj.Name)
            
            if string.find(name, "trade") or string.find(name, "sell") or string.find(name, "buy") then
                -- Tentar executar com argumentos suspeitos
                local testArgs = {
                    "duplicate",
                    "hack",
                    "exploit",
                    math.huge,
                    -999999,
                    "admin",
                    "bypass"
                }
                
                local success, result = TradingExploit:ExecuteTradingRemote(obj, testArgs)
                
                if success then
                    Utils:Log("Remote de trading executado com sucesso: " .. obj.Name, "EXPLOIT")
                end
            end
        end
    end
end

function TradingExploit:ModifyPrices()
    Utils:Log("Tentando modificar preços...", "EXPLOIT")
    
    -- Procurar por valores de preço
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("IntValue") or obj:IsA("NumberValue") then
            local name = string.lower(obj.Name)
            
            if string.find(name, "price") or string.find(name, "cost") or string.find(name, "value") then
                local originalValue = obj.Value
                
                -- Tentar modificar o preço
                local success = pcall(function()
                    obj.Value = 0 -- Preço zero
                end)
                
                if success then
                    Utils:Log("Preço modificado com sucesso: " .. obj.Name .. " | Novo valor: 0", "EXPLOIT")
                    -- Restaurar valor original após teste
                    obj.Value = originalValue
                end
            end
        end
    end
end

function TradingExploit:InfiniteMoney()
    Utils:Log("Tentando obter dinheiro infinito...", "EXPLOIT")
    
    -- Procurar por valores de dinheiro
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("IntValue") or obj:IsA("NumberValue") then
            local name = string.lower(obj.Name)
            
            if string.find(name, "money") or string.find(name, "cash") or string.find(name, "coins") or string.find(name, "currency") then
                local originalValue = obj.Value
                
                -- Tentar modificar o dinheiro
                local success = pcall(function()
                    obj.Value = math.huge
                end)
                
                if success then
                    Utils:Log("Dinheiro modificado com sucesso: " .. obj.Name .. " | Novo valor: infinito", "EXPLOIT")
                    -- Restaurar valor original após teste
                    obj.Value = originalValue
                end
            end
        end
    end
end

function TradingExploit:BypassTradingLimits()
    Utils:Log("Tentando bypass de limites de trading...", "EXPLOIT")
    
    -- Procurar por scripts de validação de trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("Script") or obj:IsA("LocalScript") then
            local name = string.lower(obj.Name)
            
            if string.find(name, "trade") or string.find(name, "validate") or string.find(name, "check") then
                -- Tentar desabilitar o script
                local success = pcall(function()
                    obj.Disabled = true
                end)
                
                if success then
                    Utils:Log("Script de validação desabilitado: " .. obj.Name, "EXPLOIT")
                end
            end
        end
    end
end

function TradingExploit:ExploitTradingUI()
    Utils:Log("Tentando explorar interface de trading...", "EXPLOIT")
    
    -- Modificar elementos de UI de trading
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("ScreenGui") or obj:IsA("GuiObject") then
            local name = string.lower(obj.Name)
            
            if string.find(name, "trade") or string.find(name, "price") or string.find(name, "cost") then
                if obj:IsA("TextLabel") or obj:IsA("TextButton") then
                    local originalText = obj.Text
                    
                    -- Modificar texto para valores falsos
                    local success = pcall(function()
                        obj.Text = "0"
                    end)
                    
                    if success then
                        Utils:Log("UI de trading modificada: " .. obj.Name .. " | Novo texto: 0", "EXPLOIT")
                        -- Restaurar texto original
                        obj.Text = originalText
                    end
                end
            end
        end
    end
end

-- Main Scanner
local MainTradingScanner = {}

function MainTradingScanner:RunFullTradingScan()
    Utils:Log("=== INICIANDO SCAN COMPLETO DE TRADING ===", "SCAN")
    
    local allVulnerabilities = {}
    
    -- Scan de remotes de trading
    local remoteVulns = TradingScanner:ScanTradingRemotes()
    for _, vuln in pairs(remoteVulns) do
        table.insert(allVulnerabilities, vuln)
    end
    
    -- Scan de scripts de trading
    local scriptVulns = TradingScanner:ScanTradingScripts()
    for _, vuln in pairs(scriptVulns) do
        table.insert(allVulnerabilities, vuln)
    end
    
    -- Scan de valores de trading
    local valueVulns = TradingScanner:ScanTradingValues()
    for _, vuln in pairs(valueVulns) do
        table.insert(allVulnerabilities, vuln)
    end
    
    -- Scan de UI de trading
    local uiVulns = TradingScanner:ScanTradingUI()
    for _, vuln in pairs(uiVulns) do
        table.insert(allVulnerabilities, vuln)
    end
    
    -- Relatório
    MainTradingScanner:GenerateTradingReport(allVulnerabilities)
    
    return allVulnerabilities
end

function MainTradingScanner:GenerateTradingReport(vulnerabilities)
    Utils:Log("=== RELATÓRIO DE VULNERABILIDADES DE TRADING ===", "REPORT")
    Utils:Log("Total de vulnerabilidades encontradas: " .. #vulnerabilities, "REPORT")
    
    for i, vuln in pairs(vulnerabilities) do
        Utils:Log(string.format("[%d] %s - Severidade: %s", i, vuln.type, vuln.severity), "REPORT")
        if vuln.info then
            if type(vuln.info) == "table" then
                for key, value in pairs(vuln.info) do
                    Utils:Log("  " .. key .. ": " .. tostring(value), "REPORT")
                end
            else
                Utils:Log("  Info: " .. tostring(vuln.info), "REPORT")
            end
        end
        print("")
    end
end

function MainTradingScanner:AutoTradingExploit(vulnerabilities)
    if not CONFIG.AUTO_EXPLOIT then return end
    
    Utils:Log("=== INICIANDO AUTO-EXPLOIT DE TRADING ===", "EXPLOIT")
    
    for _, vuln in pairs(vulnerabilities) do
        if vuln.type == "EXPOSED_TRADING_REMOTE" then
            -- Tentar executar o remote
            local remote = game:FindFirstChild(vuln.info.name, true)
            if remote then
                TradingExploit:ExecuteTradingRemote(remote, {"test", "exploit", "hack"})
            end
        elseif vuln.type == "MODIFIABLE_TRADING_VALUE" then
            TradingExploit:ModifyPrices()
        elseif vuln.type == "TRADING_SCRIPT_ACCESS" then
            TradingExploit:BypassTradingLimits()
        elseif vuln.type == "MODIFIABLE_TRADING_UI" then
            TradingExploit:ExploitTradingUI()
        end
    end
    
    -- Executar exploits gerais
    TradingExploit:DuplicateItems()
    TradingExploit:InfiniteMoney()
end

-- Interface de Controle
local TradingInterface = {}

function TradingInterface:ShowMenu()
    Utils:Log("=== TRADING EXPLOIT TOOL ===", "MENU")
    Utils:Log("1. Executar scan completo de trading", "MENU")
    Utils:Log("2. Scan de remotes de trading apenas", "MENU")
    Utils:Log("3. Scan de valores de trading apenas", "MENU")
    Utils:Log("4. Tentar duplicar itens", "MENU")
    Utils:Log("5. Tentar modificar preços", "MENU")
    Utils:Log("6. Tentar dinheiro infinito", "MENU")
    Utils:Log("7. Bypass de limites de trading", "MENU")
    Utils:Log("8. Auto-exploit de trading", "MENU")
    Utils:Log("9. Sair", "MENU")
end

-- Inicialização
Utils:Log("Trading Exploit Tool carregado com sucesso!", "INFO")
Utils:Log("Use TradingInterface:ShowMenu() para ver as opções", "INFO")

-- Expor funções globais
_G.TradingExploit = {
    Scanner = MainTradingScanner,
    Exploit = TradingExploit,
    Interface = TradingInterface,
    Utils = Utils
}

-- Auto-executar scan inicial
spawn(function()
    wait(2)
    Utils:Log("Executando scan inicial de trading...", "INFO")
    local vulns = MainTradingScanner:RunFullTradingScan()
    if CONFIG.AUTO_EXPLOIT then
        MainTradingScanner:AutoTradingExploit(vulns)
    end
end)

return _G.TradingExploit